// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package main

import (
	"context"
	"errors"
	"fmt"
	"net"

	"github.com/containernetworking/cni/pkg/skel"
	cniTypes "github.com/containernetworking/cni/pkg/types"
	cniTypesV1 "github.com/containernetworking/cni/pkg/types/100"
	"github.com/containernetworking/plugins/pkg/ns"
	"github.com/go-openapi/swag"
	"github.com/sirupsen/logrus"
	"github.com/vishvananda/netlink"

	"github.com/cilium/cilium/api/v1/models"
	"github.com/cilium/cilium/pkg/client"
	"github.com/cilium/cilium/pkg/datapath/connector"
	"github.com/cilium/cilium/pkg/datapath/linux/linux_defaults"
	"github.com/cilium/cilium/pkg/datapath/linux/route"
	datapathOption "github.com/cilium/cilium/pkg/datapath/option"
	"github.com/cilium/cilium/pkg/defaults"
	iputil "github.com/cilium/cilium/pkg/ip"
	"github.com/cilium/cilium/pkg/labels"
	"github.com/cilium/cilium/pkg/logging/logfields"
	"github.com/cilium/cilium/pkg/netns"
	"github.com/cilium/cilium/pkg/sysctl"
	"github.com/cilium/cilium/plugins/cilium-cni/types"
)

const (
	// attachmentLabelName is the name of the label added to CEPs which represent attachments to
	// secondary networks.
	attachmentLabelName = "com.isovalent.v1alpha1.network.attachment"

	// labelSourceCNI is the label source for labels generated by the CNI plugin.
	labelSourceCNI = "cni"
)

func additionalRoutes(routes []*models.NetworkAttachmentRoute, doIPv6 bool, mtu int, state *CmdState) (result []*cniTypes.Route, err error) {
	for _, r := range routes {
		dstIP, dstPrefix, err := net.ParseCIDR(r.Destination)
		if err != nil {
			return nil, fmt.Errorf("invalid route destination: %w", err)
		}

		var gwIP net.IP
		if r.Gateway != "" {
			gwIP = net.ParseIP(r.Gateway)
			if gwIP == nil {
				return nil, fmt.Errorf("invalid route gateway %q", r.Gateway)
			}
		}

		isIPv6Route := dstIP.To4() == nil
		if isIPv6Route != doIPv6 {
			continue
		}

		var resultRoutes []route.Route
		resultRoutes = append(resultRoutes, route.Route{
			Prefix:  *dstPrefix,
			Nexthop: &gwIP,
			MTU:     mtu,
		})

		if gwIP != nil {
			resultRoutes = append(resultRoutes, route.Route{
				Prefix: *iputil.IPToPrefix(gwIP),
			})
		}

		if doIPv6 {
			state.IP6routes = append(state.IP6routes, resultRoutes...)
		} else {
			state.IP4routes = append(state.IP4routes, resultRoutes...)
		}

		for _, resultRoute := range resultRoutes {
			result = append(result, newCNIRoute(resultRoute))
		}
	}

	return result, nil
}

func installMultiNetworkSourceRoutes(networkNumber int, networkInterface string, routeMTU int, ipam *models.IPAMResponse) error {
	// This is shouldn't conflict with the main routing table IDs (253-255) because we don't
	// expect more than 243 (253-10) networks being used at the same time.
	tableID := linux_defaults.RouteTableInterfacesOffset + networkNumber

	if ipv4IsEnabled(ipam) {
		err := route.Upsert(route.Route{
			Prefix: defaults.IPv4DefaultRoute,
			Device: networkInterface,
			MTU:    routeMTU,
			Table:  tableID,
		})
		if err != nil {
			return err
		}

		rule := route.Rule{
			From:     iputil.IPToPrefix(net.ParseIP(ipam.Address.IPV4)),
			Table:    tableID,
			Protocol: linux_defaults.RTProto,
		}
		err = route.ReplaceRule(rule)
		if err != nil {
			return err
		}
	}

	if ipv6IsEnabled(ipam) {
		err := route.Upsert(route.Route{
			Prefix: defaults.IPv6DefaultRoute,
			Device: networkInterface,
			MTU:    routeMTU,
			Table:  tableID,
		})
		if err != nil {
			return err
		}

		rule := route.Rule{
			From:     iputil.IPToPrefix(net.ParseIP(ipam.Address.IPV6)),
			Table:    tableID,
			Protocol: linux_defaults.RTProto,
		}
		err = route.ReplaceRuleIPv6(rule)
		if err != nil {
			return err
		}
	}

	return nil
}

func multiNetworkCmdAdd(
	args *skel.CmdArgs,
	n *types.NetConf,
	logger *logrus.Entry,
	cniArgs *types.ArgsSpec,
	c *client.Client,
	netNs ns.NetNS,
	conf *models.DaemonConfigurationStatus,
) (err error) {
	res := &cniTypesV1.Result{}

	// fetch network attachments
	networks, err := c.NetworkAttachments(string(cniArgs.K8S_POD_NAMESPACE), string(cniArgs.K8S_POD_NAME))
	if err != nil {
		return err
	}

	for i, network := range networks.Attachments {
		isPrimaryNetwork := i == 0 // first network is always assumed "primary"
		ifName := args.IfName
		containerID := args.ContainerID
		podName := string(cniArgs.K8S_POD_NAME)
		podNamespace := string(cniArgs.K8S_POD_NAMESPACE)
		ipamPoolName := network.Ipam.IpamPool
		networkName := swag.StringValue(network.Name)

		if !isPrimaryNetwork {
			// Use a unique prefix for the secondary interface names, so we don't clash
			// with interfaces e.g. created by Multus which uses "net".
			ifName = fmt.Sprintf("cil%d", i)
		}

		if err = netns.RemoveIfFromNetNSIfExists(netNs, ifName); err != nil {
			return fmt.Errorf("failed removing interface %q from namespace %q: %w",
				ifName, args.Netns, err)
		}

		ipam, releaseIPsFunc, err := allocateIPsWithCiliumAgent(c, cniArgs, ipamPoolName)

		// release addresses on failure
		defer func() {
			if err != nil && releaseIPsFunc != nil {
				releaseIPsFunc(context.TODO())
			}
		}()

		if err != nil {
			return err
		}

		if err = connector.SufficientAddressing(ipam.HostAddressing); err != nil {
			return fmt.Errorf("IP allocation addressing in insufficient: %w", err)
		}

		var lbls labels.Labels
		if !isPrimaryNetwork {
			lbls = labels.Labels{
				attachmentLabelName: labels.NewLabel(attachmentLabelName, networkName, labelSourceCNI),
			}
			logger.WithField("label", lbls.String()).Debug("adding label for secondary endpoint")
		}

		ep := &models.EndpointChangeRequest{
			ContainerID:              containerID,
			Labels:                   lbls.GetModel(),
			State:                    models.EndpointStateWaitingDashForDashIdentity.Pointer(),
			Addressing:               &models.AddressPair{},
			K8sPodName:               podName,
			K8sNamespace:             podNamespace,
			DatapathConfiguration:    &models.EndpointDatapathConfiguration{},
			ContainerInterfaceName:   ifName,
			DisableLegacyIdentifiers: !isPrimaryNetwork,
		}

		switch conf.DatapathMode {
		case datapathOption.DatapathModeVeth:
			var (
				veth      *netlink.Veth
				peer      netlink.Link
				tmpIfName string
			)
			id := containerID + ":" + ifName
			veth, peer, tmpIfName, err = connector.SetupVeth(id, int(conf.DeviceMTU),
				int(conf.GROMaxSize), int(conf.GSOMaxSize),
				int(conf.GROIPV4MaxSize), int(conf.GSOIPV4MaxSize), ep)
			if err != nil {
				return fmt.Errorf("unable to set up veth on host side: %w", err)
			}
			defer func() {
				if err != nil {
					if err2 := netlink.LinkDel(veth); err2 != nil {
						logger.WithError(err2).WithField(logfields.Veth, veth.Name).Warn("failed to clean up and delete veth")
					}
				}
			}()

			res.Interfaces = append(res.Interfaces, &cniTypesV1.Interface{
				Name: veth.Attrs().Name,
				Mac:  veth.Attrs().HardwareAddr.String(),
			})

			if err = netlink.LinkSetNsFd(peer, int(netNs.Fd())); err != nil {
				return fmt.Errorf("unable to move veth pair %q to netns: %w", peer, err)
			}

			err = connector.SetupVethRemoteNs(netNs, tmpIfName, ifName)
			if err != nil {
				return fmt.Errorf("unable to set up veth on container side: %w", err)
			}
		}

		var state CmdState
		if isPrimaryNetwork {
			state.HostAddr = ipam.HostAddressing
		}

		if !ipv6IsEnabled(ipam) && !ipv4IsEnabled(ipam) {
			return errors.New("IPAM did provide neither IPv4 nor IPv6 address")
		}

		var (
			ipConfig *cniTypesV1.IPConfig
			routes   []*cniTypes.Route
		)
		if ipv6IsEnabled(ipam) {
			ep.Addressing.IPV6 = ipam.Address.IPV6
			ep.Addressing.IPV6PoolName = ipam.Address.IPV6PoolName
			ep.Addressing.IPV6ExpirationUUID = ipam.IPV6.ExpirationUUID

			ipConfig, routes, err = prepareIP(ep.Addressing.IPV6, &state, int(conf.RouteMTU))
			if err != nil {
				return fmt.Errorf("unable to prepare IP addressing for %q: %w", ep.Addressing.IPV6, err)
			}
			// set the addresses interface index to that of the container-side veth
			ipConfig.Interface = cniTypesV1.Int(len(res.Interfaces))
			res.IPs = append(res.IPs, ipConfig)
			res.Routes = append(res.Routes, routes...)

			routes, err = additionalRoutes(network.Routes, true, int(conf.RouteMTU), &state)
			if err != nil {
				return fmt.Errorf("unable to install additional routes for network %q: %w", networkName, err)
			}
			res.Routes = append(res.Routes, routes...)
		}

		if ipv4IsEnabled(ipam) {
			ep.Addressing.IPV4 = ipam.Address.IPV4
			ep.Addressing.IPV4PoolName = ipam.Address.IPV4PoolName
			ep.Addressing.IPV4ExpirationUUID = ipam.IPV4.ExpirationUUID

			ipConfig, routes, err = prepareIP(ep.Addressing.IPV4, &state, int(conf.RouteMTU))
			if err != nil {
				return fmt.Errorf("unable to prepare IP addressing for %q: %w", ep.Addressing.IPV4, err)
			}
			// set the addresses interface index to that of the container-side veth
			ipConfig.Interface = cniTypesV1.Int(len(res.Interfaces))
			res.IPs = append(res.IPs, ipConfig)
			res.Routes = append(res.Routes, routes...)

			routes, err = additionalRoutes(network.Routes, false, int(conf.RouteMTU), &state)
			if err != nil {
				return fmt.Errorf("unable to install additional routes for network %q: %w", networkName, err)
			}
			res.Routes = append(res.Routes, routes...)
		}

		var macAddrStr string
		if err = netNs.Do(func(_ ns.NetNS) error {
			if ipv6IsEnabled(ipam) {
				if err := sysctl.Disable("net.ipv6.conf.all.disable_ipv6"); err != nil {
					logger.WithError(err).Warn("unable to enable ipv6 on all interfaces")
				}
			}
			macAddrStr, err = configureIface(ipam, ifName, &state)
			if err != nil {
				return err
			}

			if len(networks.Attachments) > 1 {
				if err := installMultiNetworkSourceRoutes(i, ifName, int(conf.RouteMTU), ipam); err != nil {
					return err
				}
			}

			return nil
		}); err != nil {
			return fmt.Errorf("unable to configure interfaces in container namespace: %w", err)
		}

		res.Interfaces = append(res.Interfaces, &cniTypesV1.Interface{
			Name:    ifName,
			Mac:     macAddrStr,
			Sandbox: args.Netns,
		})

		// Specify that endpoint must be regenerated synchronously. See GH-4409.
		ep.SyncBuildEndpoint = true
		if err = c.EndpointCreate(ep); err != nil {
			logger.WithError(err).WithFields(logrus.Fields{
				logfields.ContainerID: ep.ContainerID}).Warn("Unable to create endpoint")
			return fmt.Errorf("unable to create endpoint: %w", err)
		}

		logger.WithFields(logrus.Fields{
			logfields.ContainerID: ep.ContainerID}).Debug("Endpoint successfully created")
	}

	return cniTypes.PrintResult(res, n.CNIVersion)
}
